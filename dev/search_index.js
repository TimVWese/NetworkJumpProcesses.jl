var documenterSearchIndex = {"docs":
[{"location":"guide/#Package-Guide","page":"Package Guide","title":"Package Guide","text":"","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\n    \"examples/sis.md\",\n    \"examples/reaction_diffusion.md\",\n]\nDepth = 1","category":"page"},{"location":"examples/sis/#SIS","page":"SIS","title":"SIS","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"In this example, we simulate the spreading of a SIS epidemic on a contact network. Each node in the network represents a person and can be in one of two states: susceptible (0) or infective (1). Infective nodes can infect their susceptible neighbours at a rate β and recover at a rate γ.","category":"page"},{"location":"examples/sis/#Import-the-required-packages","page":"SIS","title":"Import the required packages","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"For this example, we will use the minimal packages NetworkJumpProcesses, Graphs, and JumpProcesses. Additionally, we will use the Plots package to visualise the results. The Graphs package provides the graphs on which the jump process will be defined. In this case this is the erdos_renyi function, which generates a random graph according to the Erdős–Rényi model. The NetworkJumpProcesses package provides the network_jump_set function and network jump types for defining the jump set to use in the simulation algorithms of the The JumpProcesses package. Additionally, we will use the Plots to visualise the results. Import the packages as as usual, or install them first using ] add NetworkJumpProcesses Graphs JumpProcesses Plots, if not done yet.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"using NetworkJumpProcesses\nusing Graphs\nusing JumpProcesses\nusing Plots: plot","category":"page"},{"location":"examples/sis/#Defining-the-contact-network","page":"SIS","title":"Defining the contact network","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"The contact network is defined using the erdos_renyi function. The function takes as input the number of nodes n and the probability p of an edge existing between any two nodes. In this example, we set n = 100 and p = 0.1.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"n = 100\ng = erdos_renyi(n, 0.1)","category":"page"},{"location":"examples/sis/#Defining-the-SIS-model","page":"SIS","title":"Defining the SIS model","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"The SIS model is defined using the network_jump_set function from the JumpProcesses package. The function takes as input the contact network gg and a list of vertex reactions and edge reactions. In this example, we define one vertex reaction, the curing event, and one edge reaction, the infection event. Each jump takes two functions, a rate and effect!. In the case of the vertex reaction, the rate function takes as input the state v, the neighbours nghbs, the parameters p, and the time t and returns the rate of the reaction. The effect! function takes as input the state v, the neighbours nghbs, the parameters p, and the time t and manipulates the state v to reflect the effect of the reaction. The same holds for the edge, except that the functions take as input the source state vs and the destination state vd, instead of the vertex and its neighbours state.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"v_IS = ConstantJumpVertex(\n    (v, nghbs, p, t) -> v[1] == 1 ? p[2] : 0.0,\n    (v, nghbs, p, t) -> v[1] = 0\n)\n\ne_SI = ConstantJumpEdge(\n    (vs, vd, p, t) -> vs[1] == 1 ? p[1] : 0.0,\n    (vs, vd, p, t) -> vd[1] = 1\n)","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"Having defined the jumps, the jump set can be defined as follows:","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"jset = network_jump_set(gg; vertex_reactions=[v_IS], edge_reactions=[e_SI])","category":"page"},{"location":"examples/sis/#Defining-the-problem","page":"SIS","title":"Defining the problem","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"The JumpProblem constructor defines the jump problem. It requires DiscreteProblem with initial state u₀, the time horizon (t0, tf), and the parameters p, but without any other dynamics. In this case the initial condition is such that all nodes are susceptible, except for four nodes, which are infective. The JumpProblem constructor also takes as input the problem an aggregator, and the jump set jset. In this example, we use Direct aggregation and the SSAStepper solver.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"p = (0.1, 0.08)\nu₀ = zeros(Int64, n)\nu₀[1:4] .= 1\n\ndprob = DiscreteProblem(u₀, (0, 40.0), p) \njprob = JumpProblem(dprob, Direct(), jset)\nsol = solve(jprob, SSAStepper())","category":"page"},{"location":"examples/sis/#Plotting-the-results","page":"SIS","title":"Plotting the results","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"We can now plot the number of infected agents over time.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"using Plots\n\nplot(sol.t, [count(sol[i].==1) for i in eachindex(sol.t)],\n     xlabel=\"t\", ylabel=\"I\")","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Documentation for NetworkJumpProcesses.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [NetworkJumpProcesses]","category":"page"},{"location":"reference/#NetworkJumpProcesses.ConstantJumpEdge","page":"Reference","title":"NetworkJumpProcesses.ConstantJumpEdge","text":"ConstantJumpEdge(rate, affect!)\n\nConstruct a constant rate jump over an edge with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (vs, vd, p, t) -> Real\naffect!::Function: signature (vs, vd, nghbs, p, t) -> nothing\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.ConstantJumpVertex","page":"Reference","title":"NetworkJumpProcesses.ConstantJumpVertex","text":"ConstantJumpVertex(rate, affect!)\n\nConstruct a constant rate jump vertex with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (v, nhgbs, p, t) -> Real\naffect!::Function: signature (v, nghbs, p, t)\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.VariableJumpEdge","page":"Reference","title":"NetworkJumpProcesses.VariableJumpEdge","text":"VariableJumpEdge(rate, affect!)\n\nConstruct a variable rate jump over an edge with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (vs, vd, p, t) -> Real\naffect!::Function: signature (vs, vd, nghbs, p, t) -> nothing\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.VariableJumpVertex","page":"Reference","title":"NetworkJumpProcesses.VariableJumpVertex","text":"VariableJumpVertex(rate, affect!)\n\nConstruct a variable rate jump vertex with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (v, nhgbs, p, t) -> Real\naffect!::Function: signature (v, nghbs, p, t) -> nothing\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.jumptovars","page":"Reference","title":"NetworkJumpProcesses.jumptovars","text":"jumptovars(graph, nb_vertex_reacs, nb_edge_reacs, nb_vertex_states=1)\n\nCreate a dependency graph that maps the vertex and edge reactions to the vertex states. This graph can be used for the RSSA and RSSACR aggregators.\n\nSee also: vartojumps, Jump Aggregators Requiring Dependency Graphs \n\n\n\n\n\n","category":"function"},{"location":"reference/#NetworkJumpProcesses.network_jump_set-Union{Tuple{Any}, Tuple{U}, Tuple{T}} where {T<:Union{JumpVertex, Vector{var\"#s37\"} where var\"#s37\"<:JumpVertex}, U<:Union{JumpEdge, Vector{var\"#s38\"} where var\"#s38\"<:JumpEdge}}","page":"Reference","title":"NetworkJumpProcesses.network_jump_set","text":"network_jump_set(\n    graph; vertex_reactions::Vector{T}=Vector{JumpVertex}(),\n    edge_reactions::Vector{U}=Vector{JumpEdge}(), nb_states=1\n) where {\n    T <: Union{JumpVertex, Vector{<:JumpVertex}},\n    U <: Union{JumpEdge, Vector{<:JumpEdge}}\n}\n\nConstruct a JumpSet from a Graph and a list of JumpVertex and JumpEdge reactions. vertex_reactions and edge_reactions can be either an vector of reactions which will all be applied to every vertex and edge respectively. The other option is a vector of vectors of reactions, where the ith vector of reactions will be applied to the ith vertex or edge. These variables may be mixed. Each vertex has nb_states variables associated.\n\nSee also: ConstantJumpVertex, ConstantJumpEdge, VariableJumpVertex, VariableJumpEdge\n\n\n\n\n\n","category":"method"},{"location":"reference/#NetworkJumpProcesses.vartojumps-Union{Tuple{U}, Tuple{T}, Tuple{Graphs.AbstractGraph, T, U}, Tuple{Graphs.AbstractGraph, T, U, Any}} where {T<:Union{Integer, Vector{var\"#s9\"} where var\"#s9\"<:Integer}, U<:Union{Integer, Vector{var\"#s8\"} where var\"#s8\"<:Integer}}","page":"Reference","title":"NetworkJumpProcesses.vartojumps","text":"vartojumps(graph::AbstractGraph, nb_vertex_reacs::T, nb_edge_reacs::U, nb_vertex_states=1) where {\n    T <: Union{Integer, Vector{<:Integer}},\n    U <: Union{Integer, Vector{<:Integer}}\n}\n\nCreate a dependency graph that maps the vertex states to the vertex and edge reactions. This graph can be used for the RSSA and RSSACR aggregators. If all vertices (edges) have the same number of reactions, then nb_vertex_reacs (nb_edge_reacs) can be an integer, equal to that number. Otherwise, nb_vertex_reacs (nb_edge_reacs) must be a vector of length nv(graph) (ne(graph)) , such that nb_vertex_reacs[v] (nb_edge_reacs[e]) is the number of reactions associated with vertex v (edge e).\n\nSee also: jumptovars, Jump Aggregators Requiring Dependency Graphs \n\n\n\n\n\n","category":"method"},{"location":"reference/#NetworkJumpProcesses.vertex_range-Tuple{Any, Any}","page":"Reference","title":"NetworkJumpProcesses.vertex_range","text":"vertex_range(n, v)\n\nReturns the range of vertices for a given vertex v, given that the number of states is n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NetworkJumpProcesses.vertex_to_edges-Tuple{Graphs.AbstractGraph}","page":"Reference","title":"NetworkJumpProcesses.vertex_to_edges","text":"vertex_to_edges(graph::AbstractGraph)\n\nCreate a dictionary that maps each vertex to the edges it is connected to.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkJumpProcesses.jl","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"","category":"section"},{"location":"","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"An interface between Graphs.jl and JumpProcesses.jl.","category":"page"},{"location":"#Package-features","page":"NetworkJumpProcesses.jl","title":"Package features","text":"","category":"section"},{"location":"","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"Given jumps defined on edges and vertices, the package constructs a jump process on the (undirected) graph.\nConstruct a vartojumps_map and jumps_tovars_map to use as dependency graph for a the RSSA(CR) aggregator.","category":"page"},{"location":"","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"See the Reference for all available functions.","category":"page"},{"location":"","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"There is more information about installation and use of the package in the Package Guide and hands-on examples in the Examples section.","category":"page"},{"location":"#Manual-outline","page":"NetworkJumpProcesses.jl","title":"Manual outline","text":"","category":"section"},{"location":"","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"Pages = [\n    \"guide.md\",\n    \"examples.md\",\n    \"reference.md\",\n]\nDepth = 1","category":"page"},{"location":"#Package-Limitations","page":"NetworkJumpProcesses.jl","title":"Package Limitations","text":"","category":"section"},{"location":"","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"As this is my first package and it has been developed for a specific use case, it is not as general as it could be.","category":"page"},{"location":"","page":"NetworkJumpProcesses.jl","title":"NetworkJumpProcesses.jl","text":"Directed graphs are not supported.\njump-to-jump dependencies are not supported.\nVariableJumps` are not tested.\nCoding style and performance-wise improvements.\n... (please let me know!)","category":"page"},{"location":"examples/reaction_diffusion/#Reaction-diffusion","page":"Reaction-diffusion","title":"Reaction-diffusion","text":"","category":"section"}]
}
