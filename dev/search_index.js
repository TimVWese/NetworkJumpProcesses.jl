var documenterSearchIndex = {"docs":
[{"location":"guide/#Package-Guide","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"examples/sis/#SIS","page":"SIS","title":"SIS","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"In this example, we simulate the spreading of a SIS epidemic on a contact network. Each node in the network represents a person and can be in one of two states: susceptible (0) or infective (1). Infective nodes can infect their susceptible neighbours at a rate β and recover at a rate γ.","category":"page"},{"location":"examples/sis/#Import-the-required-packages","page":"SIS","title":"Import the required packages","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"For this example, we will use the minimal packages NetworkJumpProcesses, Graphs, and JumpProcesses. Additionally, we will use the Plots package to visualise the results. The Graphs package provides the graphs on which the jump process will be defined. In this case this is the erdos_renyi function, which generates a random graph according to the Erdős–Rényi model. The NetworkJumpProcesses package provides the network_jump_set function and network jump types for defining the jump set to use in the simulation algorithms of the The JumpProcesses package. Additionally, we will use the Plots to visualise the results. Import the packages as as usual, or install them first using ] add NetworkJumpProcesses Graphs JumpProcesses Plots, if not done yet.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"using NetworkJumpProcesses\nusing Graphs\nusing JumpProcesses\nusing Plots: plot","category":"page"},{"location":"examples/sis/#Defining-the-contact-network","page":"SIS","title":"Defining the contact network","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"The contact network is defined using the erdos_renyi function. The function takes as input the number of nodes n and the probability p of an edge existing between any two nodes. In this example, we set n = 100 and p = 0.1.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"n = 100\ng = erdos_renyi(n, 0.1)","category":"page"},{"location":"examples/sis/#Defining-the-SIS-model","page":"SIS","title":"Defining the SIS model","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"The SIS model is defined using the network_jump_set function from the JumpProcesses package. The function takes as input the contact network gg and a list of vertex reactions and edge reactions. In this example, we define one vertex reaction, the curing event, and one edge reaction, the infection event. Each jump takes two functions, a rate and effect!. In the case of the vertex reaction, the rate function takes as input the state v, the neighbours nghbs, the parameters p, and the time t and returns the rate of the reaction. The effect! function takes as input the state v, the neighbours nghbs, the parameters p, and the time t and manipulates the state v to reflect the effect of the reaction. The same holds for the edge, except that the functions take as input the source state vs and the destination state vd, instead of the vertex and its neighbours state.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"v_IS = ConstantJumpVertex(\n    (v, nghbs, p, t) -> v[1] == 1 ? p[2] : 0.0,\n    (v, nghbs, p, t) -> v[1] = 0\n)\n\ne_SI = ConstantJumpEdge(\n    (vs, vd, p, t) -> vs[1] == 1 ? p[1] : 0.0,\n    (vs, vd, p, t) -> vd[1] = 1\n)","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"Having defined the jumps, the jump set can be defined as follows:","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"jset = network_jump_set(gg; vertex_reactions=[v_IS], edge_reactions=[e_SI])","category":"page"},{"location":"examples/sis/#Defining-the-problem","page":"SIS","title":"Defining the problem","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"The JumpProblem constructor defines the jump problem. It requires DiscreteProblem with initial state u₀, the time horizon (t0, tf), and the parameters p, but without any other dynamics. In this case the initial condition is such that all nodes are susceptible, except for four nodes, which are infective. The JumpProblem constructor also takes as input the problem an aggregator, and the jump set jset. In this example, we use Direct aggregation and the SSAStepper solver.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"p = (0.1, 0.08)\nu₀ = zeros(Int64, n)\nu₀[1:4] .= 1\n\ndprob = DiscreteProblem(u₀, (0, 40.0), p) \njprob = JumpProblem(dprob, Direct(), jset)\nsol = solve(jprob, SSAStepper())","category":"page"},{"location":"examples/sis/#Plotting-the-results","page":"SIS","title":"Plotting the results","text":"","category":"section"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"We can now plot the number of infected agents over time.","category":"page"},{"location":"examples/sis/","page":"SIS","title":"SIS","text":"using Plots\n\nplot(sol.t, [count(sol[i].==1) for i in eachindex(sol.t)],\n     xlabel=\"t\", ylabel=\"I\")","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Documentation for NetworkJumpProcesses.jl","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [NetworkJumpProcesses]","category":"page"},{"location":"reference/#NetworkJumpProcesses.ConstantJumpEdge","page":"Reference","title":"NetworkJumpProcesses.ConstantJumpEdge","text":"ConstantJumpEdge(rate, affect!)\n\nConstruct a constant rate jump over an edge with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (vs, vd, p, t) -> Real\naffect!::Function: signature (vs, vd, p, t) -> nothing\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.ConstantJumpVertex","page":"Reference","title":"NetworkJumpProcesses.ConstantJumpVertex","text":"ConstantJumpVertex(rate, affect!)\n\nConstruct a constant rate jump vertex with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (v, nhgbs, p, t) -> Real\naffect!::Function: signature (v, nghbs, p, t)\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.VariableJumpEdge","page":"Reference","title":"NetworkJumpProcesses.VariableJumpEdge","text":"VariableJumpEdge(rate, affect!)\n\nConstruct a variable rate jump over an edge with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (vs, vd, p, t) -> Real\naffect!::Function: signature (vs, vd, p, t) -> nothing\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.VariableJumpVertex","page":"Reference","title":"NetworkJumpProcesses.VariableJumpVertex","text":"VariableJumpVertex(rate, affect!)\n\nConstruct a variable rate jump vertex with rate rate and affect! methods.\n\nArguments\n\nrate::Function: signature (v, nhgbs, p, t) -> Real\naffect!::Function: signature (v, nghbs, p, t) -> nothing\n\nSee also: Types of Jumps\n\n\n\n\n\n","category":"type"},{"location":"reference/#NetworkJumpProcesses.jumptovars","page":"Reference","title":"NetworkJumpProcesses.jumptovars","text":"jumptovars(graph, nb_vertex_reacs, nb_edge_reacs, nb_vertex_states=1)\n\nCreate a dependency graph that maps the vertex and edge reactions to the vertex states. This graph can be used for the RSSA and RSSACR aggregators.\n\nSee also: vartojumps, Jump Aggregators Requiring Dependency Graphs \n\n\n\n\n\n","category":"function"},{"location":"reference/#NetworkJumpProcesses.network_jump_set-Union{Tuple{Any}, Tuple{U}, Tuple{T}} where {T<:Union{JumpVertex, Vector{<:JumpVertex}}, U<:Union{JumpEdge, Vector{<:JumpEdge}}}","page":"Reference","title":"NetworkJumpProcesses.network_jump_set","text":"network_jump_set(\n    graph; vertex_reactions::Vector{T}=Vector{JumpVertex}(),\n    edge_reactions::Vector{U}=Vector{JumpEdge}(), nb_states=1\n) where {\n    T <: Union{JumpVertex, Vector{<:JumpVertex}},\n    U <: Union{JumpEdge, Vector{<:JumpEdge}}\n}\n\nConstruct a JumpSet from a Graph and a list of JumpVertex and JumpEdge reactions. vertex_reactions and edge_reactions can be either an vector of reactions which will all be applied to every vertex and edge respectively. The other option is a vector of vectors of reactions, where the ith vector of reactions will be applied to the ith vertex or edge. These variables may be mixed. Each vertex has nb_states variables associated.\n\nSee also: ConstantJumpVertex, ConstantJumpEdge, VariableJumpVertex, VariableJumpEdge\n\n\n\n\n\n","category":"method"},{"location":"reference/#NetworkJumpProcesses.vartojumps-Union{Tuple{U}, Tuple{T}, Tuple{Graphs.AbstractGraph, T, U}, Tuple{Graphs.AbstractGraph, T, U, Any}} where {T<:Union{Integer, Vector{<:Integer}}, U<:Union{Integer, Vector{<:Integer}}}","page":"Reference","title":"NetworkJumpProcesses.vartojumps","text":"vartojumps(graph::AbstractGraph, nb_vertex_reacs::T, nb_edge_reacs::U, nb_vertex_states=1) where {\n    T <: Union{Integer, Vector{<:Integer}},\n    U <: Union{Integer, Vector{<:Integer}}\n}\n\nCreate a dependency graph that maps the vertex states to the vertex and edge reactions. This graph can be used for the RSSA and RSSACR aggregators. If all vertices (edges) have the same number of reactions, then nb_vertex_reacs (nb_edge_reacs) can be an integer, equal to that number. Otherwise, nb_vertex_reacs (nb_edge_reacs) must be a vector of length nv(graph) (ne(graph)) , such that nb_vertex_reacs[v] (nb_edge_reacs[e]) is the number of reactions associated with vertex v (edge e).\n\nSee also: jumptovars, Jump Aggregators Requiring Dependency Graphs \n\n\n\n\n\n","category":"method"},{"location":"reference/#NetworkJumpProcesses.vertex_range-Tuple{Any, Any}","page":"Reference","title":"NetworkJumpProcesses.vertex_range","text":"vertex_range(n, v)\n\nReturns the range of vertices for a given vertex v, given that the number of states is n.\n\n\n\n\n\n","category":"method"},{"location":"reference/#NetworkJumpProcesses.vertex_to_edges-Tuple{Graphs.AbstractGraph}","page":"Reference","title":"NetworkJumpProcesses.vertex_to_edges","text":"vertex_to_edges(graph::AbstractGraph)\n\nCreate a dictionary that maps each vertex to the edges it is connected to.\n\n\n\n\n\n","category":"method"},{"location":"#NetworkJumpProcesses.jl","page":"Home","title":"NetworkJumpProcesses.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An interface between Graphs.jl and JumpProcesses.jl.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Given jumps defined on edges and vertices, the package constructs a jump process on the (undirected) graph.\nConstruct a vartojumps_map and jumps_tovars_map to use as dependency graph for a the RSSA(CR) aggregator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Reference for all available functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is more information about installation and use of the package in the Package Guide and hands-on examples.","category":"page"},{"location":"#Manual-outline","page":"Home","title":"Manual outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"examples/sis.md\",\n    \"examples/reaction_diffusion.md\",\n]\nDepth = 1","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"guide.md\",\n    \"reference.md\",\n]\nDepth = 1","category":"page"},{"location":"#Package-Limitations","page":"Home","title":"Package Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As this is my first package and it has been developed for a specific use case, it is not as general as it could be.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Directed graphs are not supported.\njump-to-jump dependencies are not supported.\nVariableJumps` are not tested.\nCoding style and performance-wise improvements.\n... (please let me know!)","category":"page"},{"location":"examples/reaction_diffusion/#Reaction-Diffusion","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"In this example, we simulate the diffusion and reaction of two chemical elements, A and B, which might react with each other and form C. C is disposed of in some sink nodes. Over the edges there happens diffusion.","category":"page"},{"location":"examples/reaction_diffusion/#Defining-the-contact-network","page":"Reaction Diffusion","title":"Defining the contact network","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"The contact network is defined using the erdos_renyi function from the Graphs package. The function takes as input the number of nodes n and the probability of an edge between two nodes p.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"using Graphs\n\nn = 12\ngg = erdos_renyi(n, 0.4)","category":"page"},{"location":"examples/reaction_diffusion/#Defining-the-vertex-reactions","page":"Reaction Diffusion","title":"Defining the vertex reactions","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"The vertex reactions are defined using the ConstantJumpVertex(@ref) constructor. The function takes as input two anonymous functions: the first function defines the rate of the reaction, and the second function defines the update of the state. In this example, we define three vertex reactions: Asource, Bsource, and C_sink. In the first two, respectively, A and B are produced at a constant rate, while in the third one C is disposed of.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"using JumpProcesses\n\nA_source = ConstantJumpVertex(\n    (v, nghbs, p, t) -> p.rA,\n    (v, nghbs, p, t) -> v[1] += 1\n)\n\nB_source = ConstantJumpVertex(\n    (v, nghbs, p, t) -> p.rB,\n    (v, nghbs, p, t) -> v[2] += 1\n)\n\nC_sink = ConstantJumpVertex(\n    (v, nghbs, p, t) -> p.dC*v[3],\n    (v, nghbs, p, t) -> v[3] -= 1\n)","category":"page"},{"location":"examples/reaction_diffusion/#Defining-the-edge-reactions","page":"Reaction Diffusion","title":"Defining the edge reactions","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"The edge reactions are defined using the ConstantJumpEdge(@ref) function. Once again; two functions define the rate and affect the state. Note that the function signature sllightly differs from the vertex reactions. It is assumed that the diffusion is the same for all components, so it can be defined as follows.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"diffusion = i -> ConstantJumpEdge(\n    (vs, vd, p, t) -> max(p.D*(vs[i] - vd[i]), 0.),\n    (vs, vd, p, t) -> begin\n        vs[i] -= 1\n        vd[i] += 1\n    end\n)\n\ndiffusion_A = diffusion(1)\ndiffusion_B = diffusion(2)\ndiffusion_C = diffusion(3)","category":"page"},{"location":"examples/reaction_diffusion/#Defining-the-network-jump-set","page":"Reaction Diffusion","title":"Defining the network jump set","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"Since we make use heterogenous vertex jumps, we need to define an array of jumps for each node. Component C can be created in any node, and it can be disposed in three of them. A and B are also generated in 3 nodes.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"A_source_reactions = [[A_source, C_creation] for i in 1:3]\nB_source_reactions = [[B_source, C_creation] for i in 1:3]\nC_sink_reactions = [[C_sink, C_creation] for i in 1:3]\nv_reactions = vcat(A_source_reactions, B_source_reactions, C_sink_reactions)\nappend!(v_reactions, [[C_creation] for i in 1:(n-length(v_reactions))])\nshuffle!(v_reactions)","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"The edge jumps are homogeneous for all edges, so can be defined as a single array. Having the two sets of jumps, we can define the network jump set.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"e_reactions = [diffusion_A, diffusion_B, diffusion_C]\njset = network_jump_set(gg; vertex_reactions=v_reactions,\n                        edge_reactions=e_reactions, nb_states=3)","category":"page"},{"location":"examples/reaction_diffusion/#Defining-the-problem","page":"Reaction Diffusion","title":"Defining the problem","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"A discrete problem is used with initial zero state and parameter tuple p. We first use the Direct aggregator.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"p = (\n    rA = 0.1,\n    rB = 0.1,\n    rC = 0.2,\n    dC = 1.5,\n    D = 0.1\n)\n\nT = 100.0\nu₀ = zeros(Int64, 3*n)\ndprob = DiscreteProblem(u₀, (0., T), p)\ndirect_jump_prob = JumpProblem(dprob, Direct(), jset)\nsol = solve(direct_jump_prob, SSAStepper())","category":"page"},{"location":"examples/reaction_diffusion/#Plotting-the-results","page":"Reaction Diffusion","title":"Plotting the results","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"The amount of each component can be computed and plotted over time.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"using Plots\n\nget_concentrations(x::Vector{Int64}) = [\n    sum(x[i] for i in 1:3:length(x)),\n    sum(x[i] for i in 2:3:length(x)),\n    sum(x[i] for i in 3:3:length(x))\n]\n\nget_concentrations(x::ODESolution) = reduce(hcat, [get_concentrations(x[t]) for t in eachindex(x)])';\n\nplot(sol.t, get_concentrations(sol), label=[\"A\" \"B\" \"C\"], xlabel=\"t\", ylabel=\"concentration\", lw=2, legend=:topleft)","category":"page"},{"location":"examples/reaction_diffusion/#Using-dependency-graphs","page":"Reaction Diffusion","title":"Using dependency graphs","text":"","category":"section"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"It is also possible to use more performant aggregators that require dependency graphs, such as RSSA. this package provides two functions to generate the dependency graphs. Ihey require the underlying graph, the number of reactions per vertex, numer of reactions per edge and the number of states. The first two numbers can be either a single integer or an array of integers, depending on wheter the amounts are homogeneous over the vertices and edges or not. In this example, we use the same number of reactions for all edges, but not for the vertices. Hence we use the following code.","category":"page"},{"location":"examples/reaction_diffusion/","page":"Reaction Diffusion","title":"Reaction Diffusion","text":"nb_vertex_reacs = [length(v) for v in v_reactions]\nvtj = vartojumps(gg, nb_vertex_reacs, 3, 3)\njtv = jumptovars(gg, nb_vertex_reacs, 3, 3)\n\nrssa_jump_prob = JumpProblem(dprob, RSSA(), jset; vartojumps_map=vtj, jumptovars_map=jtv)\nsol = solve(rssa_jump_prob, SSAStepper())\n\nplot(sol.t, get_concentrations(sol), label=[\"A\" \"B\" \"C\"], xlabel=\"t\", ylabel=\"concentration\", lw=2, legend=:topleft)","category":"page"}]
}
